\import Arith.Int

\data SimpleInt
  | posInt Nat
  | negSuc Nat
  \where {
    \use \coerce fromNat (n : Nat) => posInt n
  }

\instance SimpleInteger : Integer SimpleInt
  | succ => isuc
  | pred => ipred
  | succPred => succ-pred
  | predSucc => pred-succ
  \where {
    \func isuc (i : SimpleInt) : SimpleInt
      | posInt n => posInt (suc n)
      | negSuc 0 => posInt 0
      | negSuc (suc n) => negSuc n

    \func ipred (i : SimpleInt) : SimpleInt
      | posInt 0 => negSuc 0
      | posInt (suc n) => posInt n
      | negSuc n => negSuc (suc n)

    \lemma succ-pred (i : SimpleInt) : isuc (ipred i) = i
      | posInt 0 => idp
      | posInt (suc n) => idp
      | negSuc n => idp

    \lemma pred-succ (i : SimpleInt) : ipred (isuc i) = i
      | posInt n => idp
      | negSuc 0 => idp
      | negSuc (suc n) => idp
  }

\func SimpleInt=Int : SimpleInt = Int =>
  path (iso f g section retraction)
  \where {
    \func f (i : SimpleInt) : Int
      | posInt n => pos n
      | negSuc n => neg (suc n)

    \func g (i : Int) : SimpleInt
      | pos n => posInt n
      | neg 0 => posInt 0
      | neg (suc n) => negSuc n

    \lemma section (i : SimpleInt) : g (f i) = i
      | posInt n => idp
      | negSuc n => idp

    \lemma retraction (i : Int) : f (g i) = i
      | pos n => idp
      | neg 0 => idp
      | neg (suc n) => idp
  }
