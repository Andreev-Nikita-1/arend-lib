\import Category
\import Category.Limit
\import Paths.Meta

\data Type (P : \Set)
  | TParam P
  | Prod (Type P) (Type P)
  | Unit

\data Term {TP : \Set} (P : Type TP -> Type TP -> \Set) (ctx : Type TP) (T : Type TP) \elim T
  | Prod A B => Tuple (Term P ctx A) (Term P ctx B)
  | Unit => unit
  | T => Proj1 {S : Type TP} (Term P ctx (Prod T S))
  | T => Proj2 {S : Type TP} (Term P ctx (Prod S T))
  | T => Param {d : Type TP} (P d T) (Term P ctx d)
  | T => Var (T = ctx)

\func IT {C : CartesianPrecat} {P : \Set} (f : P -> C) (T : Type P) : C \elim T
  | TParam p => f p
  | Prod T1 T2 => C.Bprod (IT f T1) (IT f T2)
  | Unit => C.terminal

\func I {C : CartesianPrecat} {TP : \Set} {P : Type TP -> (Type TP) -> \Set} (tf : TP -> C)
        (f : \Pi (ctx' : Type TP) -> \Pi (T' : Type TP) -> P ctx' T' -> Hom (IT tf ctx') (IT tf T'))
        {ctx : Type TP} {T : Type TP} (term : Term P ctx T)
  : Hom (IT tf ctx) (IT tf T) \elim T, term
  | Prod T1 T2, Tuple term1 term2 => C.pair (I tf f term1) (I tf f term2)
  | Unit, unit => C.terminalMap
  | T, Proj1 term => C.proj1 `o` I tf f term
  | T, Proj2 term => C.proj2 `o` I tf f term
  | T, Param {d} p t => f d T p `o` I tf f t
  | T, Var eq => rewrite eq (C.id (IT tf ctx))

\func Ih {C : CartesianPrecat} {P : \Set} (f : P -> C) (D C : Type P) => Hom (IT f D) (IT f C)